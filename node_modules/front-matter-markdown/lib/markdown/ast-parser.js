(function() {
  var AstParser, InlineLexer, Parser, Renderer, inherits;

  inherits = require('inherits-ex/lib/inherits');

  Parser = require('kramed/lib/parser');

  InlineLexer = require('./ast-inline-lexer');

  Renderer = require('./ast-builder');

  module.exports = AstParser = (function() {
    inherits(AstParser, Parser);

    AstParser.parse = function(src, options, renderer) {
      var parser;
      parser = new AstParser(options, renderer);
      return parser.parse(src);
    };

    function AstParser(options) {
      AstParser.__super__.constructor.apply(this, arguments);
      this.renderer = new Renderer;
    }

    AstParser.prototype.parse = function(src) {
      var out;
      if (!src.links) {
        src.links = {};
      }
      this.inline = new InlineLexer(src.links, this.options, this.renderer);
      this.tokens = src.reverse();
      out = [];
      while (this.next()) {
        out = out.concat(this.tok());
      }
      return out;
    };

    AstParser.prototype.tok = function() {
      var body, cell, flags, header, i, j, k, l, m, ordered, ref, ref1, ref2, row;
      if (!(this.token && this.token.hasOwnProperty('type'))) {
        return '';
      }
      switch (this.token.type) {
        case 'table':
          header = [];
          body = [];
          cell = [];
          for (i = k = 0, ref = this.token.header.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
            flags = {
              header: true,
              align: this.token.align[i]
            };
            cell = cell.concat(this.renderer.tablecell(this.inline.output(this.token.header[i]), {
              header: true,
              align: this.token.align[i]
            }));
          }
          header = header.contact(this.renderer.tablerow(cell));
          for (i = l = 0, ref1 = this.token.cells.length; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
            row = this.token.cells[i];
            cell = [];
            for (j = m = 0, ref2 = row.length; 0 <= ref2 ? m < ref2 : m > ref2; j = 0 <= ref2 ? ++m : --m) {
              cell = cell.concat(this.renderer.tablecell(this.inline.output(row[j]), {
                header: false,
                align: this.token.align[j]
              }));
            }
            body = body.concat(this.renderer.tablerow(cell));
          }
          return this.renderer.table(header, body);
        case 'blockquote_start':
          body = [];
          while (this.next().type !== 'blockquote_end') {
            body = body.concat(this.tok());
          }
          return this.renderer.blockquote(body);
        case 'list_start':
          body = [];
          ordered = this.token.ordered;
          while (this.next().type !== 'list_end') {
            body = body.concat(this.tok());
          }
          return this.renderer.list(body, ordered);
        case 'list_item_start':
          body = [];
          while (this.next().type !== 'list_item_end') {
            body = body.concat(this.token.type === 'text' ? this.parseText() : this.tok());
          }
          return this.renderer.listitem(body);
        case 'loose_item_start':
          body = [];
          while (this.next().type !== 'list_item_end') {
            body = body.concat(this.tok());
          }
          return this.renderer.listitem(body);
      }
      return AstParser.__super__.tok.apply(this, arguments);
    };

    return AstParser;

  })();

}).call(this);

//# sourceMappingURL=ast-parser.js.map
