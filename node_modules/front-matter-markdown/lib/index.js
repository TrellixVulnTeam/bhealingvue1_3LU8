(function() {
  var assignDefaults, defineProperty, extend, fmMarkdown, gAliases, getKeys, getNonNullKeys, getToc, getTocFromList, headingFilter, isArray, isFunction, isObject, isString, linksToData, markdown, matter;

  isArray = require('util-ex/lib/is/type/array');

  isString = require('util-ex/lib/is/type/string');

  isObject = require('util-ex/lib/is/type/object');

  isFunction = require('util-ex/lib/is/type/function');

  defineProperty = require('util-ex/lib/defineProperty');

  extend = require('util-ex/lib/_extend');

  matter = require('gray-matter');

  markdown = require('./markdown');

  getTocFromList = require('./markdown/get-toc-from-list');

  getToc = require('./markdown/get-toc-from-heading');

  headingFilter = require('./gen-heading-filter');

  getKeys = Object.keys;

  gAliases = {};

  assignDefaults = function(aOptions, aConfig) {
    var j, k, len, ref, v;
    ref = getKeys(gAliases);
    for (j = 0, len = ref.length; j < len; j++) {
      k = ref[j];
      if (aConfig[k] != null) {
        v = gAliases[k];
        if (aOptions[v] == null) {
          aOptions[v] = aConfig[k];
        }
      }
    }
    return aOptions;
  };

  getNonNullKeys = function(aObject) {
    var result;
    return result = getKeys(aObject).filter(function(k) {
      return aObject[k] != null;
    });
  };

  linksToData = function(aLinks) {
    var k, result, v;
    result = {};
    for (k in aLinks) {
      v = aLinks[k];
      if (getNonNullKeys(v).length === 1) {
        result[k] = v.href;
      } else {
        result[k] = v;
      }
    }
    return result;
  };

  module.exports = fmMarkdown = function(aContent, aOptions) {
    var compiled, err, error, headings, result, toc, vSkipSize;
    if (isObject(aOptions)) {
      aOptions = extend({
        strict: true
      }, aOptions);
    } else {
      aOptions = {
        strict: true
      };
    }
    if (aOptions.strict) {
      result = matter(aContent, aOptions);
    } else {
      try {
        result = matter(aContent, aOptions);
      } catch (error) {
        err = error;
        result = {
          content: aContent,
          data: {
            error: err
          }
        };
      }
    }
    vSkipSize = aContent.length - result.content.length;
    aContent = result.content;
    result = result.data;
    if (vSkipSize > 0) {
      result.skipSize = vSkipSize;
    }
    if (!aContent) {
      return result;
    }
    if (!(result.content || aOptions.content === false)) {
      defineProperty(result, 'content', aContent);
    }
    assignDefaults(aOptions, result);
    if (isString(aOptions.heading)) {
      headings = [aOptions.heading];
    } else if (isArray(aOptions.heading)) {
      headings = aOptions.heading;
    } else {
      headings = ['toc', /table of content/, 'summary'];
    }
    compiled = markdown.lexer(aContent);
    if (aOptions.content !== false) {
      defineProperty(result, '$compiled', compiled);
    }
    if (aOptions.links && compiled.links) {
      result = extend(result, linksToData(compiled.links));
    }
    if (aOptions.toc) {
      toc = getTocFromList(compiled, headings);
    }
    if (!(toc && toc.contents && toc.contents.length) && aOptions.headingsAsToc) {
      aOptions = aOptions.headingsAsToc;
      if (!isObject(aOptions)) {
        aOptions = {};
      }
      aOptions.filter = headingFilter(headings, aOptions.filter);
      toc = getToc(compiled, aOptions);
    }
    if (toc && toc.contents && toc.contents.length) {
      extend(result, toc);
    }
    return result;
  };

  fmMarkdown.setOptionAlias = function(aOptionName, aAlias) {
    if (aOptionName !== 'toc' && aOptionName !== 'heading' && aOptionName !== 'headingsAsToc') {
      throw new TypeError('invalid option name');
    }
    if (isArray(aAlias)) {
      aAlias.forEach(function(i) {
        return gAliases[i] = aOptionName;
      });
    } else if (isString(aAlias)) {
      gAliases[aAlias] = aOptionName;
    }
    return gAliases;
  };

}).call(this);

//# sourceMappingURL=index.js.map
